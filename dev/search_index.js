var documenterSearchIndex = {"docs":
[{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Modules = [ComponentArrays]","category":"page"},{"location":"api/#ComponentArrays.Axis","page":"API","title":"ComponentArrays.Axis","text":"ax = Axis(nt::NamedTuple)\n\nGives named component access for ComponentArrays.\n\nExamples\n\njulia> using ComponentArrays\n\njulia> ax = Axis((a = 1, b = ViewAxis(2:7, PartitionedAxis(2, (a = 1, b = 2))), c = ViewAxis(8:10, (a = 1, b = 2:3))));\n\njulia> A = [100, 4, 1.3, 1, 1, 4.4, 0.4, 2, 1, 45];\n\njulia> ca = ComponentArray(A, ax)\nComponentArray{Float64}(a = 100.0, b = [(a = 4.0, b = 1.3), (a = 1.0, b = 1.0), (a = 4.4, b = 0.4)], c = (a = 2.0, b = [1.0, 45.0]))\n\njulia> ca.a\n100.0\n\njulia> ca.b\n3-element Array{ComponentArray{Float64,1,SubArray{Float64,1,Array{Float64,1},Tuple{UnitRange{Int64}},true},Tuple{Axis{(a = 1, b = 2)}}},1}:\n (a = 4.0, b = 1.3)\n (a = 1.0, b = 1.0)\n (a = 4.4, b = 0.4)\n\njulia> ca.c\nComponentArray{SubArray{Float64,1,Array{Float64,1},Tuple{UnitRange{Int64}},true}}(a = 2.0, b = [1.0, 45.0])\n\njulia> ca.c.b\n2-element view(::Array{Float64,1}, 9:10) with eltype Float64:\n  1.0\n 45.0\n\n\n\n\n\n","category":"type"},{"location":"api/#ComponentArrays.ComponentArray","page":"API","title":"ComponentArrays.ComponentArray","text":"x = ComponentArray(nt::NamedTuple)\nx = ComponentArray(;kwargs...)\nx = ComponentArray(data::AbstractVector, ax)\nx = ComponentArray{T}(args...; kwargs...) where T\n\nArray type that can be accessed like an arbitrary nested mutable struct.\n\nExamples\n\njulia> using ComponentArrays\n\njulia> x = ComponentArray(a=1, b=[2, 1, 4], c=(a=2, b=[1, 2]))\nComponentArray{Float64}(a = 1.0, b = [2.0, 1.0, 4.0], c = (a = 2.0, b = [1.0, 2.0]))\n\njulia> x.c.a = 400; x\nComponentArray{Float64}(a = 1.0, b = [2.0, 1.0, 4.0], c = (a = 400.0, b = [1.0, 2.0]))\n\njulia> x[5]\n400.0\n\njulia> collect(x)\n7-element Array{Float64,1}:\n   1.0\n   2.0\n   1.0\n   4.0\n 400.0\n   1.0\n   2.0\n\n\n\n\n\n","category":"type"},{"location":"api/#ComponentArrays.ComponentMatrix","page":"API","title":"ComponentArrays.ComponentMatrix","text":"x = ComponentMatrix(data::AbstractMatrix, ax...)\nx = ComponentMatrix{T}(data::AbstractMatrix, ax...) where T\n\nA ComponentMatrix is an alias for a two-dimensional ComponentArray.\n\n\n\n\n\n","category":"type"},{"location":"api/#ComponentArrays.ComponentVector","page":"API","title":"ComponentArrays.ComponentVector","text":"x = ComponentVector(nt::NamedTuple)\nx = ComponentVector(;kwargs...)\nx = ComponentVector(data::AbstractVector, ax)\nx = ComponentVector{T}(args...; kwargs...) where T\n\nA ComponentVector is an alias for a one-dimensional ComponentArray.\n\n\n\n\n\n","category":"type"},{"location":"api/#ComponentArrays.PartitionedAxis","page":"API","title":"ComponentArrays.PartitionedAxis","text":"pa = PartitionedAxis(partition_size, index_map)\n\nAxis for creating arrays of ComponentArrays\n\n\n\n\n\n","category":"type"},{"location":"api/#ComponentArrays.ShapedAxis","page":"API","title":"ComponentArrays.ShapedAxis","text":"sa = ShapedAxis(shape, index_map)\n\nPreserves higher-dimensional array components in ComponentArrays (matrix components, for example)\n\n\n\n\n\n","category":"type"},{"location":"api/#ComponentArrays.ViewAxis","page":"API","title":"ComponentArrays.ViewAxis","text":"va = ViewAxis(parent_index, index_map)\n\nAxis for creating arrays of ComponentArrays\n\n\n\n\n\n","category":"type"},{"location":"api/#ComponentArrays.fastindices-Tuple","page":"API","title":"ComponentArrays.fastindices","text":"fastindices(i...)\n\nWrap ComponentArray symbolic indices in Vals for type-stable indexing.\n\nExamples\n\njulia> using ComponentArrays, BenchmarkTools\n\njulia> ca = ComponentArray(a=1, b=[2, 1, 4], c=(a=2, b=[1, 2]))\nComponentArray{Float64}(a = 1.0, b = [2.0, 1.0, 4.0], c = (a = 2.0, b = [1.0, 2.0]))\n\njulia> ca2 = ca .* ca'\n7×7 ComponentArray{Tuple{Axis{(a = 1, b = 2:4, c = (5:7, (a = 1, b = 2:3)))},Axis{(a = 1, b = 2:4, c = (5:7, (a = 1, b = \n2:3)))}},Float64,2,Array{Float64,2}}:\n 1.0  2.0  1.0   4.0  2.0  1.0  2.0\n 2.0  4.0  2.0   8.0  4.0  2.0  4.0\n 1.0  2.0  1.0   4.0  2.0  1.0  2.0\n 4.0  8.0  4.0  16.0  8.0  4.0  8.0\n 2.0  4.0  2.0   8.0  4.0  2.0  4.0\n 1.0  2.0  1.0   4.0  2.0  1.0  2.0\n 2.0  4.0  2.0   8.0  4.0  2.0  4.0\n\njulia> _a, _b, _c = fastindices(:a, :b, :c)\n(Val{:a}(), Val{:b}(), Val{:c}())\n\njulia> @btime $ca2[:c,:c];\n  12.199 μs (2 allocations: 80 bytes)\n\njulia> @btime $ca2[$_c, $_c];\n  14.728 ns (2 allocations: 80 bytes)\n\n\n\n\n\n","category":"method"},{"location":"api/#ComponentArrays.getaxes-Tuple{ComponentArray}","page":"API","title":"ComponentArrays.getaxes","text":"getaxes(x::ComponentArray)\n\nAccess .axes field of a ComponentArray. This is different than axes(x::ComponentArray), which     returns the axes of the contained array.\n\nExamples\n\njulia> using ComponentArrays\n\njulia> ax = Axis(a=1:3, b=(4:6, (a=1, b=2:3)))\nAxis{(a = 1:3, b = (4:6, (a = 1, b = 2:3)))}()\n\njulia> A = zeros(6,6);\n\njulia> ca = ComponentArray(A, (ax, ax))\n6×6 ComponentArray{Tuple{Axis{(a = 1:3, b = (4:6, (a = 1, b = 2:3)))},Axis{(a = 1:3, b = (4:6, (a = 1, b = 2:3)))}},Float64,2,Array{Float64,2}}:\n 0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0\n\njulia> getaxes(ca)\n(Axis{(a = 1:3, b = (4:6, (a = 1, b = 2:3)))}(), Axis{(a = 1:3, b = (4:6, (a = 1, b = 2:3)))}())\n\n\n\n\n\n","category":"method"},{"location":"api/#ComponentArrays.getdata-Tuple{ComponentArray}","page":"API","title":"ComponentArrays.getdata","text":"getdata(x::ComponentArray)\n\nAccess .data field of a ComponentArray, which contains the array that ComponentArray wraps.\n\n\n\n\n\n","category":"method"},{"location":"quickstart/#Quick-Start-1","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quickstart/#General-use-1","page":"Quick Start","title":"General use","text":"","category":"section"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"The easiest way to construct 1-dimensional ComponentArrays is as if they were NamedTuples. In fact, a good way to think about them is as arbitrarily nested, mutable NamedTuples that can be passed through a solver.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"julia> c = (a=2, b=[1, 2]);\n  \njulia> x = ComponentArray(a=1.0, b=[2, 1, 4], c=c)\nComponentVector{Float64}(a = 1.0, b = [2.0, 1.0, 4.0], c = (a = 2.0, b = [1.0, 2.0]))\n  \njulia> x.c.a = 400; x\nComponentVector{Float64}(a = 1.0, b = [2.0, 1.0, 4.0], c = (a = 400.0, b = [1.0, 2.0]))\n  \njulia> x[5]\n400.0\n  \njulia> collect(x)\n7-element Array{Float64,1}:\n   1.0\n   2.0\n   1.0\n   4.0\n 400.0\n   1.0\n   2.0\n\njulia> typeof(similar(x, Int32)) === typeof(ComponentVector{Int32}(a=1, b=[2, 1, 4], c=c))\ntrue","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"Higher dimensional ComponentArrays can be created too, but it's a little messy at the moment. The nice thing for modeling is that dimension expansion through broadcasted operations can create higher-dimensional ComponentArrays automatically, so Jacobian cache arrays that are created internally with false .* x .* x' will be ComponentArrays with proper axes. Check out the ODE with Jacobian example in the examples folder to see how this looks in practice.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"julia> x2 = x .* x'\n7×7 ComponentArray{Tuple{Axis{(a = 1, b = 2:4, c = (5:7, (a = 1, b = 2:3)))},Axis{(a = 1, b = 2:4, c = (5:7, (a = 1, b = 2:3)))}},Float64,2,Array{Float64,2}}:\n 1.0  2.0  1.0   4.0  2.0  1.0  2.0\n 2.0  4.0  2.0   8.0  4.0  2.0  4.0\n 1.0  2.0  1.0   4.0  2.0  1.0  2.0\n 4.0  8.0  4.0  16.0  8.0  4.0  8.0\n 2.0  4.0  2.0   8.0  4.0  2.0  4.0\n 1.0  2.0  1.0   4.0  2.0  1.0  2.0\n 2.0  4.0  2.0   8.0  4.0  2.0  4.0\n \njulia> x2[:c,:c]\n3×3 ComponentArray{Tuple{Axis{(a = 1, b = 2:3)},Axis{(a = 1, b = 2:3)}},Float64,2,SubArray{Float64,2,Array{Float64,2},Tuple{UnitRange{Int64},UnitRange{Int64}},false}}:\n 4.0  2.0  4.0\n 2.0  1.0  2.0\n 4.0  2.0  4.0\n \njulia> x2[:a,:a]\n 1.0\n \njulia> x2[:a,:c]\nComponentArray{Float64}(a = 2.0, b = [1.0, 2.0])\n\njulia> x2[:b,:c]\n3×3 ComponentArray{Tuple{Axis{NamedTuple()},Axis{(a = 1, b = 2:3)}},Float64,2,SubArray{Float64,2,Array{Float64,2},Tuple{UnitRange{Int64},UnitRange{Int64}},false}}:\n 4.0  2.0  4.0\n 2.0  1.0  2.0\n 8.0  4.0  8.0","category":"page"},{"location":"examples/coulomb_control/#Control-of-a-sliding-block-1","page":"Control of a sliding block","title":"Control of a sliding block","text":"","category":"section"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"using ComponentArrays\nusing DifferentialEquations\nusing Interact: @manipulate\nusing Parameters: @unpack\nusing Plots","category":"page"},{"location":"examples/coulomb_control/#Problem-Setup-1","page":"Control of a sliding block","title":"Problem Setup","text":"","category":"section"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"const g = 9.80665\n\nmaybe_apply(f::Function, x, p, t) = f(x, p, t)\nmaybe_apply(f, x, p, t) = f\n\n# Applies functions of form f(x,p,t) to be applied and passed in as inputs\nfunction simulator(func; kwargs...)\n    simfun(dx, x, p, t) = func(dx, x, p, t; map(f->maybe_apply(f, x, p, t), (;kwargs...))...)\n    simfun(x, p, t) = func(x, p, t; map(f->maybe_apply(f, x, p, t), (;kwargs...))...)\n    return simfun\nend\n\nsoftsign(x) = tanh(1e3x)","category":"page"},{"location":"examples/coulomb_control/#Component-Functions-1","page":"Control of a sliding block","title":"Component Functions","text":"","category":"section"},{"location":"examples/coulomb_control/#A-sliding-block-with-two-different-friction-models-1","page":"Control of a sliding block","title":"A sliding block with two different friction models","text":"","category":"section"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"# Sliding block with viscous friction\nfunction viscous_block!(D, vars, p, t; u=0.0)\n    @unpack m, c, k = p\n    @unpack v, x = vars\n\n    D.x = v\n    D.v = (-c*v + k*(u-x))/m\n    return x\nend\n\n# Sliding block with coulomb friction\nfunction coulomb_block!(D, vars, p, t; u=0.0)\n    @unpack m, μ, k = p\n    @unpack v, x = vars\n\n    D.x = v\n    a = -μ*g*softsign(v) + k*(u-x)/m\n    D.v = abs(a)<1e-3 && abs(v)<1e-3 ? -10v : a #deadzone to help the simulation\n    return x\nend","category":"page"},{"location":"examples/coulomb_control/#PID-feedback-control-1","page":"Control of a sliding block","title":"PID feedback control","text":"","category":"section"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"function PID_controller!(D, vars, p, t; err=0.0, v=0.0)\n    @unpack kp, ki, kd = p\n    @unpack x = vars\n\n    D.x = ki*err\n    return x + kp*err + kd*v\nend\n\nfunction feedback_sys!(D, components, p, t; ref=0.0)\n    @unpack ctrl, plant = components\n\n    u = p.ctrl.fun(D.ctrl, ctrl, p.ctrl.params, t; err=ref-plant.x, v=-plant.v)\n    return p.plant.fun(D.plant, plant, p.plant.params, t; u=u)\nend\n\nstep_input(;time=1.0, mag=1.0) = (x,p,t) -> t>time ? mag : 0\nsine_input(;mag=1.0, period=10.0) = (x,p,t) -> mag*sin(t*2π/period)\n\n# Equivalent viscous damping coefficient taken from:\n# https://engineering.purdue.edu/~deadams/ME563/lecture2010.pdf\nvisc_equiv(μ, N, ω, mag) = 4*μ*N/(π*ω*mag)","category":"page"},{"location":"examples/coulomb_control/#Open-Loop-Response-1","page":"Control of a sliding block","title":"Open-Loop Response","text":"","category":"section"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"To see the open-loop response of the coulomb system, let's set the input to 5 and plot the results. ","category":"page"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"const tspan = (0.0, 30.0)\nconst m = 50.0\nconst μ = 0.1\nconst k = 50.0\n\np = (m=m, μ=μ, k=k)\nic = ComponentArray(v=0, x=0)\n\nODEProblem(simulator(coulomb_block!, u=5), ic, tspan, p) |> solve |> plot","category":"page"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"(Image: )","category":"page"},{"location":"examples/coulomb_control/#Closed-Loop-Response-1","page":"Control of a sliding block","title":"Closed-Loop Response","text":"","category":"section"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"For the closed-loop response, let's make an interactive GUI. Since we are using ComponentArrays, we don't have to change anything about our plant model to incorporate it in the overall system simulation.","category":"page"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"p = (\n    ctrl = (\n        params = (kp=13, ki=12, kd=5),\n        fun = PID_controller!,\n    ),\n    plant = (\n        params = plant_p,\n        fun = coulomb_block!,\n    ),\n)\n\nic = ComponentArray(ctrl=(;x=0), plant=plant_ic)\n\nsol = ODEProblem(simulator(feedback_sys!, ref=10), ic, tspan, p) |> solve\nplot(sol, vars=3)","category":"page"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"## Interactive GUI for switching out plant models and varying PID gains\n@manipulate for kp in 0:0.01:15,\n                ki in 0:0.01:15, \n                kd in 0:0.01:15,\n                damping in Dict(\n                    \"Coulomb\" => coulomb_block!,\n                    \"Viscous\" => viscous_block!,\n                ),\n                reference in Dict(\n                    \"Sine\" => sine_input,\n                    \"Step\" => step_input,\n                ),\n                magnitude in 0:0.01:10, # pop-pop!\n                period in 1:0.01:30,\n                plot_v in false\n    \n    # Inputs\n    tspan = (0.0, 30.0)\n\n    ctrl_fun = PID_controller!\n    # plant_fun = coulomb_block!\n    \n    ref = if reference==sine_input\n        reference(period=period, mag=magnitude)\n        else\n        reference(mag=magnitude)\n    end\n    \n    m = 50.0\n    μ = 0.1\n    ω = 2π/period\n    c = 4*μ*m*g/(π*ω*magnitude) # Viscous equivalent damping\n    k = 50.0\n\n    plant_p = (m=m, μ=μ, c=c, k=k) # We'll just put everything for both models in here\n    ctrl_p = (kp=kp, ki=ki, kd=kd)\n\n    plant_ic = (v=0, x=0)\n    ctrl_ic = (;x=0)\n\n\n\n    # Set up and solve\n    sys_p = (\n        ctrl = (\n            params = ctrl_p,\n            fun = ctrl_fun,\n        ),\n        plant = (\n            params = plant_p,\n            fun = damping,\n        ),\n    )\n    sys_ic = ComponentArray(ctrl=ctrl_ic, plant=plant_ic)\n    sys_fun = ODEFunction(simulator(feedback_sys!, ref=ref), syms=[:u, :v, :x])\n    sys_prob = ODEProblem(sys_fun, sys_ic, tspan, sys_p)\n\n    sol = solve(sys_prob, Tsit5())\n\n\n    # Plot\n    t = tspan[1]:0.1:tspan[2]\n    lims = magnitude*[-1, 1]\n    plotvars = plot_v ? [3, 2] : [3]\n    strip = plot(t, ref.(0, 0, t), ylim=1.2lims, label=\"r(t)\")\n    plot!(strip, sol, vars=plotvars)\n    phase = plot(ref.(0, 0, t), map(x->x.plant.x, sol(t).u),\n        xlim=lims,\n        ylim=1.2lims,\n        legend=false,\n        xlabel=\"r(t)\",\n        ylabel=\"x(t)\",\n    )\n    plot(strip, phase, layout=(2, 1), size=(700, 800))\n\nend","category":"page"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"(Image: )","category":"page"},{"location":"examples/DiffEqFlux/#Neural-ODEs-with-DiffEqFlux-1","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"","category":"section"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"Let's see how easy it is to make dense neural ODE layers from scratch. Flux is used here just for the glorot_uniform function and the ADAM optimizer.","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"This example is taken from https://diffeqflux.sciml.ai/dev/Flux/. ","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"using ComponentArrays\nusing OrdinaryDiffEq\nusing Plots\nusing UnPack\n\nusing DiffEqFlux: sciml_train\nusing Flux: glorot_uniform, ADAM\nusing Optim: LBFGS","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"u0 = Float32[2.; 0.]\ndatasize = 30\ntspan = (0.0f0, 1.5f0)","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"First, let's make a function that creates dense neural layer components. It is similar to Flux.Dense, except it doesn't handle the activation function. We'll do that separately.","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"dense_layer(in, out) = ComponentArray(W=glorot_uniform(out, in), b=zeros(out))","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"Now we create the truth data.","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"function trueODEfunc(du, u, p, t)\n    true_A = [-0.1 2.0; -2.0 -0.1]\n    du .= ((u.^3)'true_A)'\nend\nt = range(tspan[1], tspan[2], length = datasize)\nprob = ODEProblem(trueODEfunc, u0, tspan)\node_data = Array(solve(prob, Tsit5(), saveat = t))","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"We can define a neural ODE function.","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"function dudt(u, p, t)\n    @unpack L1, L2 = p\n    return L2.W * tanh.(L1.W * u.^3 .+ L1.b) .+ L2.b\nend\n\nprob = ODEProblem(dudt, u0, tspan)","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"Our parameter vector will be a ComponentArray that holds the ODE initial conditions and the dense neural layers. This enables it to pass through the solver as a flat array while giving us the convenience of struct-like access to the components.","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"layers = (L1=dense_layer(2, 50), L2=dense_layer(50, 2))\nθ = ComponentArray(u=u0, p=layers)","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"Now let's define prediction and loss functions as well as a callback function to observe training","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"predict_n_ode(θ) = Array(solve(prob, Tsit5(), u0=θ.u, p=θ.p, saveat=t))\n\nfunction loss_n_ode(θ)\n    pred = predict_n_ode(θ)\n    loss = sum(abs2, ode_data .- pred)\n    return loss, pred\nend\nloss_n_ode(θ)\n\ncb = function (θ, loss, pred; doplot=false)\n    display(loss)\n    # plot current prediction against data\n    pl = scatter(t, ode_data[1,:], label = \"data\")\n    scatter!(pl, t, pred[1,:], label = \"prediction\")\n    display(plot(pl))\n    return false\nend","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"And now let's train!","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"cb(θ, loss_n_ode(θ)...)\n\ndata = Iterators.repeated((), 1000)\n\nres1 = sciml_train(loss_n_ode, θ, ADAM(0.05); cb=cb, maxiters=100)\ncb(res1.minimizer, loss_n_ode(res1.minimizer)...; doplot=true)\n\nres2 = sciml_train(loss_n_ode, res1.minimizer, LBFGS(); cb=cb)\ncb(res2.minimizer, loss_n_ode(res2.minimizer)...; doplot=true)","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"(Image: )","category":"page"},{"location":"examples/ODE_jac/#ODE-with-Jacobian-1","page":"ODE with Jacobian","title":"ODE with Jacobian","text":"","category":"section"},{"location":"examples/ODE_jac/#","page":"ODE with Jacobian","title":"ODE with Jacobian","text":"This example shows how to use ComponentArrays for composing Jacobian update functions as well as ODE functions. Note using plain symbols to index into ComponentArrays is still pretty slow. Until symbolic indexing is faster, the convenience function fastindices can be used to speed up simulation. The general syntax looks like","category":"page"},{"location":"examples/ODE_jac/#","page":"ODE with Jacobian","title":"ODE with Jacobian","text":"_x, _y, _z = fastindices(:x, :y, :z)\nD[_x,_y] = σ","category":"page"},{"location":"examples/ODE_jac/#","page":"ODE with Jacobian","title":"ODE with Jacobian","text":"For more information on fastindices, see its entry in the API section.","category":"page"},{"location":"examples/ODE_jac/#","page":"ODE with Jacobian","title":"ODE with Jacobian","text":"using ComponentArrays\nusing DifferentialEquations\nusing Parameters: @unpack\n\n\ntspan = (0.0, 20.0)\n\n\n## Lorenz system\nfunction lorenz!(D, u, p, t; f=0.0)\n    @unpack σ, ρ, β = p\n    @unpack x, y, z = u\n    \n    D.x = σ*(y - x)\n    D.y = x*(ρ - z) - y - f\n    D.z = x*y - β*z\n    return nothing\nend\nfunction lorenz_jac!(D, u, p, t)\n    @unpack σ, ρ, β = p\n    @unpack x, y, z = u\n    \n    D[:x,:x] = -σ\n    D[:x,:y] = σ\n\n    D[:y,:x] = ρ\n    D[:y,:y] = -1\n    D[:y,:z] = -x\n\n    D[:z,:x] = y\n    D[:z,:y] = x\n    D[:z,:z] = -β\n    return nothing\nend\n\nlorenz_p = (σ=10.0, ρ=28.0, β=8/3)\nlorenz_ic = ComponentArray(x=0.0, y=0.0, z=0.0)\nlorenz_fun = ODEFunction(lorenz!, jac=lorenz_jac!)\nlorenz_prob = ODEProblem(lorenz_fun, lorenz_ic, tspan, lorenz_p)\n\n\n## Lotka-Volterra system\nfunction lotka!(D, u, p, t; f=0.0)\n    @unpack α, β, γ, δ = p\n    @unpack x, y = u\n    \n    D.x =  α*x - β*x*y + f\n    D.y = -γ*y + δ*x*y\n    return nothing\nend\nfunction lotka_jac!(D, u, p, t)\n    @unpack α, β, γ, δ = p\n    @unpack x, y = u\n    \n    D[:x,:x] = α - β*y\n    D[:x,:y] = -β*x\n\n    D[:y,:x] = δ*y\n    D[:y,:y] = -γ + δ*x\n    return nothing\nend\n\nlotka_p = (α=2/3, β=4/3, γ=1.0, δ=1.0)\nlotka_ic = ComponentArray(x=1.0, y=1.0)\nlotka_fun = ODEFunction(lotka!, jac=lotka_jac!)\nlotka_prob = ODEProblem(lotka_fun, lotka_ic, tspan, lotka_p)\n\n\n## Composed Lorenz and Lotka-Volterra system\nfunction composed!(D, u, p, t)\n    c = p.c #coupling parameter\n    @unpack lorenz, lotka = u\n    \n    lorenz!(D.lorenz, lorenz, p.lorenz, t, f=c*lotka.x)\n    lotka!(D.lotka, lotka, p.lotka, t, f=c*lorenz.x)\n    return nothing\nend\nfunction composed_jac!(D, u, p, t)\n    c = p.c\n    @unpack lorenz, lotka = u\n    \n    lorenz_jac!(D[:lorenz,:lorenz], lorenz, p.lorenz, t)\n    lotka_jac!(D[:lotka,:lotka], lotka, p.lotka, t)\n\n    D[:lorenz,:lotka][:y,:x] = -c\n    D[:lotka,:lorenz][:x,:x] = c\n    return nothing\nend\n\ncomp_p = (lorenz=lorenz_p, lotka=lotka_p, c=0.01)\ncomp_ic = ComponentArray(lorenz=lorenz_ic, lotka=lotka_ic)\ncomp_fun = ODEFunction(composed!, jac=composed_jac!)\ncomp_prob = ODEProblem(comp_fun, comp_ic, tspan, comp_p)\n\n\n## Solve problem\n# We can solve the composed system...\ncomp_sol = solve(comp_prob, Rodas5())\n\n# ...or we can unit test one of the component systems\nlotka_sol = solve(lotka_prob, Rodas5())","category":"page"},{"location":"#ComponentArrays.jl-1","page":"Home","title":"ComponentArrays.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The main export of this package is the ComponentArray type. \"Components\" of ComponentArrays are really just array blocks that can be accessed through a named index. The magic here is that this named indexing can create a new ComponentArray whose data is a view into the original, allowing for standalone models to be composed together by simple function composition. In essence, ComponentArrays allow you to do the things you would usually need a modeling language for, but without actually needing a modeling language. The main targets are for use in DifferentialEquations.jl and Optim.jl, but anything that requires flat vectors is fair game.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"examples/example1.md\"]\nDepth = 2","category":"page"}]
}
