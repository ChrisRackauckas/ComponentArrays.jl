var documenterSearchIndex = {"docs":
[{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Modules = [ComponentArrays]","category":"page"},{"location":"api/#ComponentArrays.Axis","page":"API","title":"ComponentArrays.Axis","text":"ax = Axis(nt::NamedTuple)\n\nAxes for named component access of CArrays. These are a little confusing and poorly     thought-out, so maybe don't use them directly.\n\nExamples\n\njulia> using ComponentArrays\n\njulia> ax = Axis(a=1, b=2:3, c=(4:10, (a=(1:3, (a=1, b=2:3)), b=4:7)))\nAxis{(a = 1, b = 2:3, c = (4:10, (a = (1:3, (a = 1, b = 2:3)), b = 4:7)))}()\n\njulia> A = [100, 4, 1.3, 1, 1, 4.4, 0.4, 2, 1, 45];\n\njulia> cvec = CArray(A, ax);\n\njulia> cmat = CArray(A .* A', ax, ax);\n\njulia> cmat[:c,:c] * cvec.c\n7-element Array{Float64,1}:\n  2051.52\n  2051.52\n  9026.688000000002\n   820.608\n  4103.04\n  2051.52\n 92318.4\n\n\n\n\n\n","category":"type"},{"location":"api/#ComponentArrays.CArray","page":"API","title":"ComponentArrays.CArray","text":"x = CArray(nt::NamedTuple)\nx = CArray{T}(nt::NamedTuple) where {T}\n\nArray type that can be accessed like an arbitrary nested mutable struct.\n\nExamples\n\njulia> using ComponentArrays\n\njulia> x = CArray(a=1, b=[2, 1, 4], c=(a=2, b=[1, 2]))\nCArray{Float64}(a = 1.0, b = [2.0, 1.0, 4.0], c = (a = 2.0, b = [1.0, 2.0]))\n\njulia> x.c.a = 400; x\nCArray{Float64}(a = 1.0, b = [2.0, 1.0, 4.0], c = (a = 400.0, b = [1.0, 2.0]))\n\njulia> x[5]\n400.0\n\njulia> collect(x)\n7-element Array{Float64,1}:\n   1.0\n   2.0\n   1.0\n   4.0\n 400.0\n   1.0\n   2.0\n\n\n\n\n\n","category":"type"},{"location":"api/#ComponentArrays.fastindices-Tuple","page":"API","title":"ComponentArrays.fastindices","text":"fastindices(i...)\n\nWrap CArray symbolic indices in Vals for type-stable indexing.\n\nExamples\n\njulia> using ComponentArrays, BenchmarkTools\n\njulia> ca = CArray(a=1, b=[2, 1, 4], c=(a=2, b=[1, 2]))\nCArray{Float64}(a = 1.0, b = [2.0, 1.0, 4.0], c = (a = 2.0, b = [1.0, 2.0]))\n\njulia> ca2 = ca .* ca'\n7×7 CArray{Tuple{Axis{(a = 1, b = 2:4, c = (5:7, (a = 1, b = 2:3)))},Axis{(a = 1, b = 2:4, c = (5:7, (a = 1, b = \n2:3)))}},Float64,2,Array{Float64,2}}:\n 1.0  2.0  1.0   4.0  2.0  1.0  2.0\n 2.0  4.0  2.0   8.0  4.0  2.0  4.0\n 1.0  2.0  1.0   4.0  2.0  1.0  2.0\n 4.0  8.0  4.0  16.0  8.0  4.0  8.0\n 2.0  4.0  2.0   8.0  4.0  2.0  4.0\n 1.0  2.0  1.0   4.0  2.0  1.0  2.0\n 2.0  4.0  2.0   8.0  4.0  2.0  4.0\n\njulia> _a, _b, _c = fastindices(:a, :b, :c)\n(Val{:a}(), Val{:b}(), Val{:c}())\n\njulia> @btime $ca2[:c,:c];\n  12.199 μs (2 allocations: 80 bytes)\n\njulia> @btime $ca2[$_c, $_c];\n  14.728 ns (2 allocations: 80 bytes)\n\n\n\n\n\n","category":"method"},{"location":"api/#ComponentArrays.getaxes-Tuple{CArray}","page":"API","title":"ComponentArrays.getaxes","text":"getaxes(x::CArray)\n\nAccess .axes field of a CArray. This is different than axes(x::CArray), which     returns the axes of the contained array.\n\nExamples\n\njulia> using ComponentArrays\n\njulia> ax = Axis(a=1:3, b=(4:6, (a=1, b=2:3)))\nAxis{(a = 1:3, b = (4:6, (a = 1, b = 2:3)))}()\n\njulia> A = zeros(6,6);\n\njulia> ca = CArray(A, (ax, ax))\n6×6 CArray{Tuple{Axis{(a = 1:3, b = (4:6, (a = 1, b = 2:3)))},Axis{(a = 1:3, b = (4:6, (a = 1, b = 2:3)))}},Float64,2,Array{Float64,2}}:\n 0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0\n\njulia> getaxes(ca)\n(Axis{(a = 1:3, b = (4:6, (a = 1, b = 2:3)))}(), Axis{(a = 1:3, b = (4:6, (a = 1, b = 2:3)))}())\n\n\n\n\n\n","category":"method"},{"location":"api/#ComponentArrays.getdata-Tuple{CArray}","page":"API","title":"ComponentArrays.getdata","text":"getdata(x::CArray)\n\nAccess .data field of a CArray, which contains the array that CArray wraps.\n\n\n\n\n\n","category":"method"},{"location":"quickstart/#Quick-Start-1","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quickstart/#General-use-1","page":"Quick Start","title":"General use","text":"","category":"section"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"The easiest way to construct 1-dimensional CArrays is as if they were NamedTuples. In fact, a good way to think about them is as arbitrarily nested, mutable NamedTuples that can be passed through a solver.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"julia> c = (a=2, b=[1, 2]);\n  \njulia> x = CArray(a=1, b=[2, 1, 4], c=c)\nCArray{Float64}(a = 1.0, b = [2.0, 1.0, 4.0], c = (a = 2.0, b = [1.0, 2.0]))\n  \njulia> x.c.a = 400; x\nCArray{Float64}(a = 1.0, b = [2.0, 1.0, 4.0], c = (a = 400.0, b = [1.0, 2.0]))\n  \njulia> x[5]\n400.0\n  \njulia> collect(x)\n7-element Array{Float64,1}:\n   1.0\n   2.0\n   1.0\n   4.0\n 400.0\n   1.0\n   2.0\n\njulia> typeof(similar(x, Int32)) === typeof(CArray{Int32}(a=1, b=[2, 1, 4], c=c))\ntrue","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"Higher dimensional CArrays can be created too, but it's a little messy at the moment. The nice thing for modeling is that dimension expansion through broadcasted operations can create higher-dimensional CArrays automatically, so Jacobian cache arrays that are created internally with false .* x .* x' will be CArrays with proper axes. Check out the ODE with Jacobian example in the examples folder to see how this looks in practice.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"julia> x2 = x .* x'\n7×7 CArray{Tuple{Axis{(a = 1, b = 2:4, c = (5:7, (a = 1, b = 2:3)))},Axis{(a = 1, b = 2:4, c = (5:7, (a = 1, b = 2:3)))}},Float64,2,Array{Float64,2}}:\n 1.0  2.0  1.0   4.0  2.0  1.0  2.0\n 2.0  4.0  2.0   8.0  4.0  2.0  4.0\n 1.0  2.0  1.0   4.0  2.0  1.0  2.0\n 4.0  8.0  4.0  16.0  8.0  4.0  8.0\n 2.0  4.0  2.0   8.0  4.0  2.0  4.0\n 1.0  2.0  1.0   4.0  2.0  1.0  2.0\n 2.0  4.0  2.0   8.0  4.0  2.0  4.0\n \njulia> x2[:c,:c]\n3×3 CArray{Tuple{Axis{(a = 1, b = 2:3)},Axis{(a = 1, b = 2:3)}},Float64,2,SubArray{Float64,2,Array{Float64,2},Tuple{UnitRange{Int64},UnitRange{Int64}},false}}:\n 4.0  2.0  4.0\n 2.0  1.0  2.0\n 4.0  2.0  4.0\n \njulia> x2[:a,:a]\n 1.0\n \njulia> x2[:a,:c]\nCArray{Float64}(a = 2.0, b = [1.0, 2.0])\n\njulia> x2[:b,:c]\n3×3 CArray{Tuple{Axis{NamedTuple()},Axis{(a = 1, b = 2:3)}},Float64,2,SubArray{Float64,2,Array{Float64,2},Tuple{UnitRange{Int64},UnitRange{Int64}},false}}:\n 4.0  2.0  4.0\n 2.0  1.0  2.0\n 8.0  4.0  8.0","category":"page"},{"location":"examples/ODE_jac/#ODE-with-Jacobian-1","page":"ODE with Jacobian","title":"ODE with Jacobian","text":"","category":"section"},{"location":"examples/ODE_jac/#","page":"ODE with Jacobian","title":"ODE with Jacobian","text":"This example shows how to use ComponentArrays for composing Jacobian update functions as well as ODE functions. Note using plain symbols to index into CArrays is still pretty slow. Until symbolic indexing is faster, the convenience function fastindices can be used to speed up simulation. The general syntax looks like","category":"page"},{"location":"examples/ODE_jac/#","page":"ODE with Jacobian","title":"ODE with Jacobian","text":"_x, _y, _z = fastindices(:x, :y, :z)\nD[_x,_y] = σ","category":"page"},{"location":"examples/ODE_jac/#","page":"ODE with Jacobian","title":"ODE with Jacobian","text":"For more information on fastindices, see its entry in the API section.","category":"page"},{"location":"examples/ODE_jac/#","page":"ODE with Jacobian","title":"ODE with Jacobian","text":"using ComponentArrays\nusing DifferentialEquations\nusing Parameters: @unpack\n\n\ntspan = (0.0, 20.0)\n\n\n## Lorenz system\nfunction lorenz!(D, u, p, t; f=0.0)\n    @unpack σ, ρ, β = p\n    @unpack x, y, z = u\n    \n    D.x = σ*(y - x)\n    D.y = x*(ρ - z) - y - f\n    D.z = x*y - β*z\n    return nothing\nend\nfunction lorenz_jac!(D, u, p, t)\n    @unpack σ, ρ, β = p\n    @unpack x, y, z = u\n    \n    D[:x,:x] = -σ\n    D[:x,:y] = σ\n\n    D[:y,:x] = ρ\n    D[:y,:y] = -1\n    D[:y,:z] = -x\n\n    D[:z,:x] = y\n    D[:z,:y] = x\n    D[:z,:z] = -β\n    return nothing\nend\n\nlorenz_p = (σ=10.0, ρ=28.0, β=8/3)\nlorenz_ic = CArray(x=0.0, y=0.0, z=0.0)\nlorenz_fun = ODEFunction(lorenz!, jac=lorenz_jac!)\nlorenz_prob = ODEProblem(lorenz_fun, lorenz_ic, tspan, lorenz_p)\n\n\n## Lotka-Volterra system\nfunction lotka!(D, u, p, t; f=0.0)\n    @unpack α, β, γ, δ = p\n    @unpack x, y = u\n    \n    D.x =  α*x - β*x*y + f\n    D.y = -γ*y + δ*x*y\n    return nothing\nend\nfunction lotka_jac!(D, u, p, t)\n    @unpack α, β, γ, δ = p\n    @unpack x, y = u\n    \n    D[:x,:x] = α - β*y\n    D[:x,:y] = -β*x\n\n    D[:y,:x] = δ*y\n    D[:y,:y] = -γ + δ*x\n    return nothing\nend\n\nlotka_p = (α=2/3, β=4/3, γ=1.0, δ=1.0)\nlotka_ic = CArray(x=1.0, y=1.0)\nlotka_fun = ODEFunction(lotka!, jac=lotka_jac!)\nlotka_prob = ODEProblem(lotka_fun, lotka_ic, tspan, lotka_p)\n\n\n## Composed Lorenz and Lotka-Volterra system\nfunction composed!(D, u, p, t)\n    c = p.c #coupling parameter\n    @unpack lorenz, lotka = u\n    \n    lorenz!(D.lorenz, lorenz, p.lorenz, t, f=c*lotka.x)\n    lotka!(D.lotka, lotka, p.lotka, t, f=c*lorenz.x)\n    return nothing\nend\nfunction composed_jac!(D, u, p, t)\n    c = p.c\n    @unpack lorenz, lotka = u\n    \n    lorenz_jac!(D[:lorenz,:lorenz], lorenz, p.lorenz, t)\n    lotka_jac!(D[:lotka,:lotka], lotka, p.lotka, t)\n\n    D[:lorenz,:lotka][:y,:x] = -c\n    D[:lotka,:lorenz][:x,:x] = c\n    return nothing\nend\n\ncomp_p = (lorenz=lorenz_p, lotka=lotka_p, c=0.01)\ncomp_ic = CArray(lorenz=lorenz_ic, lotka=lotka_ic)\ncomp_fun = ODEFunction(composed!, jac=composed_jac!)\ncomp_prob = ODEProblem(comp_fun, comp_ic, tspan, comp_p)\n\n\n## Solve problem\n# We can solve the composed system...\ncomp_sol = solve(comp_prob, Rodas5())\n\n# ...or we can unit test one of the component systems\nlotka_sol = solve(lotka_prob, Rodas5())","category":"page"},{"location":"#ComponentArrays.jl-1","page":"Home","title":"ComponentArrays.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The main export of this package is the CArray type. \"Components\" of CArrays are really just array blocks that can be accessed through a named index. The magic here is that this named indexing can create a new CArray whose data is a view into the original, allowing for standalone models to be composed together by simple function composition. In essence, CArrays allow you to do the things you would usually need a modeling language for, but without actually needing a modeling language. The main targets are for use in DifferentialEquations.jl and Optim.jl, but anything that requires flat vectors is fair game.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"examples/example1.md\"]\nDepth = 2","category":"page"}]
}
